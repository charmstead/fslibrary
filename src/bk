class FsLibrary {

    constructor(cms_selector: string, animation?: Animatn) {

        this.cms_selector = cms_selector;

        if (animation) {
            animation.enable = !/^false$/.test(String(animation.enable));
            this.animation = animation;

            const effects = animation.effects.replace('fade', '');
            const { duration, easing } = animation;
            this.makeStyleSheet({ duration, easing, transform: effects })

        }
        else {
            this.makeStyleSheet({});
        }
    }

    private cms_selector: string;

    private animation: Animatn = {
        enable: true,
        duration: 1000,
        easing: 'ease-in-out',
        effects: 'fade'
    };

    private initialLayoutMode;

    private addClass: boolean;

    private addClassConfig: AddClass;

    private animationStyle: string = `
        
        .fslib-normal{
            position:relative;
        }
        .fslib-norm{
            -webkit-transition: all {{duration}}ms {{ease}};
            -moz-transition: all {{duration}}ms {{ease}};
            -o-transition: all {{duration}}ms {{ease}};
            transition: all {{duration}}ms {{ease}};
        }
        
        .no-flicker{
            -webkit-transform:translate3d(0,0,0);
            -webkit-transform-style: preserve-3d;
            -webkit-backface-visibility: hidden;
        }
        .notransition {
            -webkit-transition: none !important;
            -moz-transition: none !important;
            -o-transition: none !important;
            transition: none !important;
          }

        .fslib-transform{
            transform:{{transform}};
        }
        
    
          @keyframes fade-in {
            0% {
                opacity: 0;
            }
            100% {
                transform:translate(0) rotate(0) scale(0);
                opacity: 1;
            }
          }
          
          .fslib-fadeIn {
            animation-name: fade-in;
            animation-duration: 1s;
            animation-iteration-count: 1;
            animation-fill-mode: forwards;
          }
    `;

    private makeStyleSheet({ duration = 250, easing = 'ease-in-out', transform = 'translate(0)' }) {

        this.animationStyle = this.animationStyle.replace('{{duration}}', '' + duration);
        this.animationStyle = this.animationStyle.replace('{{ease}}', easing);
        this.animationStyle = this.animationStyle.replace('{{transform}}', transform);

        const head = document.head || document.getElementsByTagName('head')[0];
        const style: any = document.createElement('style');
        head.appendChild(style);

        style.type = 'text/css';
        if (style.styleSheet) {
            // This is required for IE8 and below.
            style.styleSheet.cssText = this.animationStyle;
        } else {
            style.appendChild(document.createTextNode(this.animationStyle));
        }
    }

    /**
     * Combine all the collection items into one collection.
     */
    public combine() {

        //get all collections
        const master_collection: any = [].slice.call(document.querySelectorAll(this.cms_selector));

        //copies the cms items into the first collection list
        master_collection[0].innerHTML = (
            [...master_collection].reduce((curr, items) => {
                //gets all the items  
                return [...curr, ...items.innerHTML]
            }, []).join("")
        )

        //deletes the rest collection list
        master_collection.forEach((elem: Element, i: number) => {
            if (i > 0) {
                elem.outerHTML = ""
            }
        })


    }



    public loadmore(config: LoadMore = { button: "", actualLoadMore: true, initialLoad: 12, loadPerClick: 12 }): void {

        if (!this.initialLayoutMode) {
            this.setInitialLayoutMode();
        }

        const parent: any = document.querySelector(this.cms_selector);
        const collection: any[] = [].slice.call(parent.children);
        const clone: any[] = [].slice.call(parent.cloneNode(true).children);

        const { button, actualLoadMore, initialLoad, loadPerClick } = config;

        let reserve = [];
        reserve = clone.filter((child, i) => {

            if (i < initialLoad) {
                return false;
            }

            collection[i].outerHTML = "";
            return true;
        });

        (<any>document.querySelector(button)).onclick = () => {
            const addon = reserve.splice(0, loadPerClick);
            addon.map((elem) => {
                elem.classList.add('fslib-fadeIn')
                document.querySelector(this.cms_selector).appendChild(elem);
            })

            if (this.addClass) {
                this.addClasses(this.addClassConfig);
            }

            if (reserve.length == 0) {
                (<any>document.querySelector(button)).style.display = 'none';
            }
        }



    }


    /**
     * 
     * @param container The css selector of the parent container elem of the list you want to add classnames to.
     * @param config  defined as
     *  {
     *     classNames: Array<AltClass>; //list of classnames you want to add
     *     frequency: number; //The frequency or order of addition of class to the list
     *     start: number; //position of list item to start with
     * }
     */
    public addClasses(config: AddClass = { classNames: [], frequency: 2, start: 1 }): void {

        if (!this.initialLayoutMode) {
            this.setInitialLayoutMode();
        }

        const parent: any = document.querySelector(this.cms_selector);
        const { frequency, start, classNames } = config;

        this.addClassConfig = config;
        this.addClass = true;

        if (frequency < 0) {
            throw "unaccepted value passed as frequency";
        }
        else if (start < 1) {
            throw "unaccepted value passed as start";
        }

        classNames.map(({ target, alt }) => {
            const list = parent.querySelectorAll(target);
            for (let j = start - 1; j < list.length; j += frequency) {

                const addon = alt.replace(/\./g, "")
                if (list[j].className.indexOf(addon) < 0) {
                    list[j].className += " " + addon
                }

                if (frequency == 0) {
                    break;
                }
            }
        })
    }

    private setInitialLayoutMode() {

        const get_cms_items: any = () => [].slice.call(document.querySelectorAll(this.cms_selector));

        //storing initial layoutMode
        this.initialLayoutMode = this.getLayoutMode();
    }

    private getLayoutMode() {

        const get_cms_items: any = () => [].slice.call(document.querySelectorAll(this.cms_selector));
        return (
            get_cms_items().map((elem, i) => {
                elem.style['justify-content']='left'
                elem.style['overflow']='hidden'
                return (
                    [].slice.call(elem.children).map((item, j) => {
                        item.style.transform='translate3d(0,0,0)'
                        const coordinates = item.getBoundingClientRect();
                        return {
                            x: coordinates.left,
                            y: coordinates.top
                        };
                    }))
            })
        );
    }

    /**
     * 
     * @param cms_selector 
     */
    public cmsfilter(cms_filter = [], filter_type = 'single') {
        const animation = this.animation;
        const animationQueue = [];
        const flag = [];

        //incase filter was clicked before animation ends
        let clickCheck = 0;



        let filter: Array<{ [key: string]: string }> = []//2D array to hold categories of filter selectors and their corresponding

        //get all collections

        const get_cms_items: any = () => [].slice.call(document.querySelectorAll(this.cms_selector));

        if (!this.initialLayoutMode) {
            this.setInitialLayoutMode();
        }

        let filter_group: any[] = [];

        if (Array.isArray(cms_filter)) {
            cms_filter.map((val, index) => {
                let prevClicked;
                const { filter_option } = val;

                filter_group = [].slice.call(document.querySelectorAll(`${(<any>val).filter_group} [data-search]`));
                assignChangeEventToButtons(index, prevClicked, filter_option)

            })
        }
        else if (typeof cms_filter == "string") {
            let prevClicked;
            filter_group = [].slice.call(document.querySelectorAll(`${cms_filter} [data-search]`));
            assignChangeEventToButtons(0, prevClicked)
        }
        else {
            throw "Incorrect type passed as cms_filter"
        }


        function assignChangeEventToButtons(index, prevClicked, filter_option = filter_type) {
            filter[index] = {} //initialise default values
            filter_group.map((elem, j) => {
                const id = `${index}${j}`;
                const tag_element = elem && elem.tagName;

                if (tag_element == "SELECT") {
                    (<any>elem).onchange = function (event) {
                        let filter_text = event.currentTarget.selectedOptions[0].getAttribute("data-search") || '';

                        filterHelper({ filter_option, id, index, filter_text })
                    }
                }
                else if (tag_element == "INPUT") {//handle checkbox and radio button
                    (<any>elem).onchange = function (event) {
                        let filter_text = event.currentTarget.getAttribute("data-search") || '';

                        if (!event.target.checked) {
                            filter_text = '';
                        }
                        filterHelper({ filter_option, id, index, filter_text })
                    }
                }
                else {
                    (<any>elem).onclick = function (event) {
                        const active = event.currentTarget.className;

                        //only one element should have active class for or
                        if (/^single$/i.test(filter_type) || /^single$/i.test(filter_option)) {
                            if (prevClicked) prevClicked.classList.remove("active")
                        }

                        prevClicked = event.currentTarget;

                        if (active.includes("active")) {
                            prevClicked.classList.remove("active")
                        }
                        else {
                            prevClicked.classList.add("active")
                        }

                        let filter_text = prevClicked.getAttribute("data-search") || '';
                        filterHelper({ filter_option, id, index, filter_text })
                    }
                }
            })
        }


        function filterHelper({ filter_option, id, index, filter_text }) {
            clickCheck++;
            if (/^single$/i.test(filter_type) || /^single$/i.test(filter_option)) {

                //checks if it has previously been clicked                
                if (id in filter[index]) {
                    delete filter[index][id];
                }
                else {
                    filter[index] = {};
                    filter[index][id] = filter_text;
                }

            }
            else {//it is definitely "multi"

                //checks if it has previously been clicked
                if (id in filter[index]) {

                    delete filter[index][id];
                }
                else {
                    filter[index][id] = filter_text;
                }

            }
            findAndMatchFilterText();

        }


        const findAndMatchFilterText = () => {
            const master_collection = get_cms_items();
            master_collection.map((elem, i) => {


                if (!elem.classList.contains('fslib-normal')) {
                    elem.classList.add('fslib-normal')
                }


                const search_result = filter.reduce((curr, search) => {

                    //creating a regex to test against
                    const val = `(${Object["values"]((search)).join("|")})`;

                    const result = [].slice.call(elem.children).map((item, j) => {

                        const re = new RegExp(val, "i");
                        const valid = re.test(item.textContent);

                        const clonedItem = item.cloneNode(true);

                        if (valid) {
                            clonedItem.style.display = "block"
                        }
                        else {
                            clonedItem.style.display = "none"
                        }

                        // return clonedItem.outerHTML;
                        return clonedItem;
                    })

                    if (curr.length < 1) {
                        return result;
                    }

                    // return [...curr.filter((a) => result.includes(a))]

                    //intersections of the results
                    return [...curr.map((a, index) => {
                        if (a.style.display !== result[index].style.display) {
                            a.style.display = "none";
                        }
                        return a;
                    })]

                }, [])//.join("").trim()

                let pos = 0;

                if (search_result.length > 1) {
                    [].slice.call(master_collection[i].children)
                        .map((child, k) => {

                            if (!animationQueue[k]) {
                                animationQueue[k] = []
                            }

                            if (!animation.enable) {
                                child.style.display = search_result[k].style.display;
                                return;
                            }

           
                            const finalX = this.initialLayoutMode[i][pos].x;
                            const finalY = this.initialLayoutMode[i][pos].y;

                                              

                            if (search_result[k].style.display == 'none') {

                                //Animate only visible elements
                                if (child.style.opacity !== 0) {



                                    animationQueue[k].push(

                                        {
                                            time: animation.duration / 1000,
                                            node: child,
                                            deltaX: 0,
                                            deltaY: 0,
                                            start: function () {
                                                const curr = this.node.getBoundingClientRect();

                                                this.deltaX = finalX - curr.x;
                                                this.deltaY = finalY - curr.y;
                                            },
                                            run: function (rate) {
                                                flag[k] = 1;
                                                const deltaX = rate * this.deltaX + "px";
                                                const deltaY = rate * this.deltaY + "px";
                                                child.style.opacity = .5 - rate;
                                                child.style.zIndex = 1;

                                                child.style
                                                    .transform = `rotateZ(${rate * 100}deg) translate(${rate * 0}px, ${rate * 0}px)`;

                                            },
                                            complete: function () {
                                                flag[k] = 0;
                                                child.style.transform = `translate(0)`;
                                                child.style.display = `none`;
                                                // child.style.position = `absolute`;
                                                // child.style.display = `inline-block`;



                                            }
                                        }
                                    );

                                    if (!flag[k]) {
                                        animate(animationQueue[k]);
                                    }


                                }

                            }
                            else {
                                // child.style.display=''
                                animationQueue[k].push(
                                    {
                                        time: animation.duration / 1000,
                                        node: child,
                                        deltaX: 0,
                                        deltaY: 0,
                                        start: function () {
                                            if(child.style.display!=="none"){
                                            child.style = ``;

                                            }
                                            
                                            const currX = child.getBoundingClientRect().x;
                                            const currY = child.getBoundingClientRect().y;
                                            this.deltaX = finalX - currX;
                                            this.deltaY = finalY - currY;
                                          
                                        },
                                        run: function (rate) {
                              
                                            flag[k] = 1;
                                            const deltaX = rate * this.deltaX + "px";
                                            const deltaY = rate * this.deltaY + "px";

                                            if (child.style.opacity && child.style.opacity < 1) {
                                                child.style.opacity = rate;
                                            }
                                            child.style.zIndex = 3;

                                            child.style
                                                .transform = `translate3d(${deltaX}, ${deltaY},0)`;
                                            
                             
                                        },
                                        complete: function () {
                                            flag[k] = 0;
                                            child.style = `
                                               transform:translate3d(0,0,0);
                                               transform-style: preserve-3d;
                                               backface-visibility: hidden;
                                            `;

                                            // child.style.transform = `translate(0)`;
                                            // child.style.position = `static`;
                                        }
                                    }
                                );

                                if (!flag[k]) {
                                    animate(animationQueue[k]);
                                }

                                pos++;
                            }

                        });

                }

            })
        }
    }
}

interface AltClass {
    target: string;
    alt: string
}

interface LoadMore {
    button: string;
    actualLoadMore: boolean;
    initialLoad: number;
    loadPerClick: number
}

interface AddClass {
    classNames: Array<AltClass>; //list of classnames you want to add
    frequency: number; //The frequency or order of addition of class to the list
    start: number; //position of list item to start with
}

interface FilterGroup {
    filter_group: string;
    filter_option: string
}

interface Animatn {
    enable?: boolean;
    easing?: string;
    duration?: number;
    effects?: string;
}


interface Filter {
    cms_filter: FilterGroup[] | string;
    filter_type: string;
}

const _requestAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame ||
    (<any>window).mozRequestAnimationFrame ||
    function (callback) {
        window.setTimeout(callback, 1000 / 60);
    };

const animate = (list) => {

    let item,
        duration,
        end = 0;

    let step = function () {

        let current = +new Date(),
            remaining = end - current;


        if (remaining < 60) {

            if (item) {
                item.run(1);  //1 = progress is at 100%
                item.complete()
            }

            item = list.shift();  //get the next item

            if (item) {
                console.log(item)
                duration = item.time * 1000;
                end = current + duration;
                item.start()
                item.run(0);  //0 = progress is at 0%
            } else {
                return;
            }

        } else {
            let rate = remaining / duration;
            rate = 1 - Math.pow(rate, 3);  //easing formula
            item.run(rate);
        }


        _requestAnimationFrame(step);

    };
    step();
}

function getAbsoluteBoundingRect(el) {
    var doc = document,
        win = window,
        body = doc.body,

        // pageXOffset and pageYOffset work everywhere except IE <9.
        offsetX = win.pageXOffset !== undefined ? win.pageXOffset :
            (<any>(doc.documentElement || body.parentNode || body)).scrollLeft,
        offsetY = win.pageYOffset !== undefined ? win.pageYOffset :
            (<any>(doc.documentElement || body.parentNode || body)).scrollTop,

        rect = el.getBoundingClientRect();

    if (el !== body) {
        var parent = el.parentNode;

        // The element's rect will be affected by the scroll positions of
        // *all* of its scrollable parents, not just the window, so we have
        // to walk up the tree and collect every scroll offset. Good times.
        while (parent !== body) {
            offsetX += parent.scrollLeft;
            offsetY += parent.scrollTop;
            parent = parent.parentNode;
        }
    }

    return {
        bottom: rect.bottom + offsetY,
        height: rect.height,
        left: rect.left + offsetX,
        right: rect.right + offsetX,
        top: rect.top + offsetY,
        width: rect.width
    };
}

(<any>window).FsLibrary =FsLibrary;